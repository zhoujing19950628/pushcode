太好了，有你的目录树和“leader 的 spec”可以直接落地了。下面给你一套「在项目目录内完成」的打包方案：不需要 Docker、不改动系统级 rpmbuild 目录，所有中间产物都放在你项目下。思路是把源码+系统d服务+离线 wheelhouse 打包到一个 tarball，安装时在 /opt/kylin-ai-cryptojacking-detect 下创建 venv 并从 wheelhouse 装依赖。

一、在项目里准备打包素材（一次性搭好骨架）

在项目根 ~/Downloads/kylin-ai-cryptojacking-detect 里执行：

# 1) 变量
NAME="kylin-ai-cryptojacking-detect"
VERSION="1.0.0"
TOPDIR="$(pwd)/.rpmbuild"          # 全部放项目内
PKGDIR="$(pwd)/packaging"          # 临时打包素材目录
LAYOUT="$PKGDIR/${NAME}-${VERSION}"# tarball 的顶层目录名

# 2) 目录骨架
rm -rf "$PKGDIR" ".rpmbuild"
mkdir -p "$LAYOUT/opt/$NAME"
mkdir -p "$LAYOUT/usr/local/bin"
mkdir -p "$LAYOUT/opt/$NAME/wheelhouse_x86_64"
mkdir -p "$LAYOUT/opt/$NAME/wheelhouse_aarch64"

# 3) 拷贝你的源码（保持你现在的 src 结构）
cp -a src "$LAYOUT/opt/$NAME/"

# 4) 生成运行包装脚本（可转发参数）
cat > "$LAYOUT/usr/local/bin/$NAME" <<'EOF'
#!/usr/bin/env bash
set -euo pipefail
INSTALL_DIR="/opt/kylin-ai-cryptojacking-detect"
VENV="$INSTALL_DIR/kylin-ai-cryptojacking-detect-venv"
exec "$VENV/bin/python3" "$INSTALL_DIR/src/cryptojacking_detect.py" --monitor "$@"
EOF
chmod 755 "$LAYOUT/usr/local/bin/$NAME"

# 5) Systemd 单元（开机自启，可根据需要调整 User/Environment）
cat > "$LAYOUT/${NAME}.service" <<'EOF'
[Unit]
Description=Kylin AI Cryptojacking Detect
After=network.target

[Service]
Type=simple
# 如需非 root 运行，可改为 User=kylin
ExecStart=/usr/local/bin/kylin-ai-cryptojacking-detect
Restart=always
RestartSec=3
WorkingDirectory=/opt/kylin-ai-cryptojacking-detect
# 保留环境变量以便读取你 L1/L2/L3 的配置（按需增减）
Environment=PYTHONUNBUFFERED=1

[Install]
WantedBy=multi-user.target
EOF

# 6) 依赖清单（示例，按你项目实际增减）
cat > "$LAYOUT/opt/$NAME/requirements.txt" <<'EOF'
psutil
pandas
PyYAML
websocket-client
scikit-learn
EOF


可选：如果希望某些配置升级时不覆盖，建议将 L1 的 monitoring_rules.yaml 放在 /opt/$NAME/etc/ 并在程序里优先从 /opt/$NAME/etc/monitoring_rules.yaml 读取（下面 spec 已把你现在的位置标成 %config(noreplace)，也能保护用户改动）。

二、准备离线 wheelhouse（在项目路径内）

分别在 x86_64 和 aarch64 机器上下载对应轮子（有 C 扩展的包如 psutil 需要在目标架构下载）：

# x86_64 机器上：
pip download -r "$LAYOUT/opt/$NAME/requirements.txt" -d "$LAYOUT/opt/$NAME/wheelhouse_x86_64"

# aarch64 机器上：
#（把项目拷到一台 ARM 机器，执行同样命令到 wheelhouse_aarch64）
pip download -r "$LAYOUT/opt/$NAME/requirements.txt" -d "$LAYOUT/opt/$NAME/wheelhouse_aarch64"


如果暂时没有 ARM 机器，也可以先只放 x86_64 的 wheelhouse，安装在 aarch64 时会失败；等需要时再补齐重打包。

三、打出 Source0 tarball（仍在项目内）
mkdir -p "$TOPDIR"/{SOURCES,SPECS,BUILD,BUILDROOT,RPMS,SRPMS}
( cd "$PKGDIR" && tar czf "$TOPDIR/SOURCES/${NAME}-${VERSION}.tar.gz" "${NAME}-${VERSION}" )

四、SPEC（放到项目的 .rpmbuild/SPECS/ 下）

把下面内容保存为：.rpmbuild/SPECS/kylin-ai-cryptojacking-detect.spec

Name:           kylin-ai-cryptojacking-detect
Version:        1.0.0
Release:        1%{?dist}
Summary:        Kylin AI Cryptojacking Detection (L1/L2/L3)

License:        Proprietary
URL:            http://www.kylinos.cn
Source0:        %{name}-%{version}.tar.gz

# 仅在包内做架构裁剪；包本身做成 noarch，以便一包通用
BuildArch:      noarch
ExcludeArch:    loongarch64

Requires:       python3 >= 3.6
Requires:       systemd

%description
Kylin AI cryptojacking detection tool (Python). It bundles source code,
a systemd service, and per-arch wheelhouses to create a local venv on install.

%prep
%setup -q

%build
# 无需构建

%install
rm -rf %{buildroot}
# 安装到 /opt/kylin-ai-cryptojacking-detect
mkdir -p %{buildroot}/opt/%{name}
cp -a opt/%{name}/* %{buildroot}/opt/%{name}/

# 安装 systemd 服务
mkdir -p %{buildroot}/etc/systemd/system
install -m 644 %{_builddir}/%{name}-%{version}/%{name}.service %{buildroot}/etc/systemd/system/%{name}.service

# 安装启动包装脚本
mkdir -p %{buildroot}/usr/local/bin
install -m 755 %{_builddir}/%{name}-%{version}/usr/local/bin/%{name} %{buildroot}/usr/local/bin/%{name}

# （可选）编译 pyc 并剔除源码；如需保留源码可注释掉下面两段
# 1) 编译
/usr/bin/find %{buildroot}/opt/%{name} -name "*.py" -print0 | \
  xargs -0 -I{} /usr/bin/python3 - <<'PY'
import py_compile, sys
for p in sys.stdin.read().splitlines():
    try:
        py_compile.compile(p, cfile=p+"c")
    except Exception as e:
        print("py_compile failed:", p, e)
PY
# 2) 删除除 __init__.py 外的 .py
/usr/bin/find %{buildroot}/opt/%{name} -name "*.py" -not -name "__init__.py" -not -path "*/venv/*" -delete

%post
#!/bin/sh
set -e
INSTALL_DIR="/opt/%{name}"
VENV_PATH="$INSTALL_DIR/%{name}-venv"

echo "Creating virtual environment at $VENV_PATH"
python3 -m venv "$VENV_PATH"

ARCH=$(uname -m)
case "$ARCH" in
    x86_64)  WHEELHOUSE="$INSTALL_DIR/wheelhouse_x86_64" ;;
    aarch64) WHEELHOUSE="$INSTALL_DIR/wheelhouse_aarch64" ;;
    *)
        echo "Unsupported architecture: $ARCH" >&2
        exit 1
        ;;
esac

echo "Installing Python dependencies from $WHEELHOUSE..."
"$VENV_PATH/bin/pip" install --no-index --find-links="$WHEELHOUSE" -r "$INSTALL_DIR/requirements.txt" || {
    echo "Failed to install dependencies" >&2
    exit 1
}

chmod 755 /usr/local/bin/%{name}
systemctl daemon-reload >/dev/null 2>&1 || :
systemctl enable %{name}.service >/dev/null 2>&1 || :
echo "Installation completed."

%preun
#!/bin/sh
set -e
if [ "$1" -eq 0 ]; then
    systemctl stop %{name}.service >/dev/null 2>&1 || :
    systemctl disable %{name}.service >/dev/null 2>&1 || :
    # 如需彻底清理虚拟环境，解除下一行注释
    # rm -rf "/opt/%{name}/%{name}-venv" || :
fi

%postun
#!/bin/sh
set -e
if [ "$1" -ge 1 ]; then
    systemctl daemon-reload >/dev/null 2>&1 || :
fi

%files
%dir /opt/%{name}
/opt/%{name}
/usr/local/bin/%{name}
/etc/systemd/system/%{name}.service

# 将你的规则文件标记为配置（如果路径有变请同步）
%config(noreplace) /opt/%{name}/src/miner_sentinel_l1/src/config/monitoring_rules.yaml

%changelog
* Mon Oct 27 2025 You <you@example.com> 1.0.0-1
- First release for Kylin


注意：上面修正了你 leader spec 里 /etc/systemd/systemkylin-ai-malware-detect.service 少斜杠的错误，这里是正确的 /etc/systemd/system/%{name}.service。

五、在项目内完成构建
rpmbuild --define "_topdir $TOPDIR" -ba "$TOPDIR/SPECS/${NAME}.spec"


产物：

二进制包：.rpmbuild/RPMS/noarch/${NAME}-${VERSION}-1.noarch.rpm

源码包：.rpmbuild/SRPMS/${NAME}-${VERSION}-1.src.rpm

之所以 noarch：我们同时装入两套 wheelhouse，安装脚本按运行机器架构裁剪实际使用；一个包通吃（除了显式排除的 loongarch64）。

六、安装与验证
sudo rpm -Uvh ".rpmbuild/RPMS/noarch/${NAME}-${VERSION}-1.noarch.rpm"

# 首次启动与查看
sudo systemctl start ${NAME}.service
sudo systemctl status ${NAME}.service

# 验证文件列表
rpm -ql ${NAME} | sed -n '1,120p'


运行日志默认跟随 systemd，你也可以在 unit 里加：

StandardOutput=journal
StandardError=journal


用 journalctl -u ${NAME} -f 实时看。

常见可调项（按需改）

只保留 L1 运行：把 /usr/local/bin/$NAME 的 ExecStart 改为带你需要的参数，或者在脚本里设置环境变量（例如 MINER_LEVEL=L1），你的入口脚本据此分支。

保留源码：把 %install 段里“编译 pyc & 删除 .py”的两段注释掉即可。

线上装依赖（不打包 wheelhouse）：可把 %post 里的 --no-index --find-links 改为线上 pip install -r，但这会引入外网依赖，不推荐。

配置文件外置：将规则文件放 /opt/$NAME/etc/monitoring_rules.yaml，并在程序里优先读取外置目录，可在 %files 再标 %config(noreplace)。

需要我把上面的命令合成一个一键 make rpm 的脚本吗？或者帮你精简 requirements.txt 到只覆盖你实际 import 的包也行。
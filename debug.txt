set -euo pipefail
NAME=kylin-ai-cryptojacking-detect
VER=0.1.0

# 0) 确保子包都有 __init__.py（按你的目录树补全一次）
touch src/miner_sentinel_l1/__init__.py \
      src/miner_sentinel_l1/src/__init__.py \
      src/miner_sentinel_l2/__init__.py \
      src/miner_sentinel_l2/src/__init__.py \
      src/miner_sentinel_l2/src/detectors/__init__.py \
      src/miner_sentinel_l2/src/models/__init__.py \
      src/miner_sentinel_l2/src/utils/__init__.py \
      src/miner_sentinel_l3/__init__.py \
      src/miner_sentinel_l3/src/__init__.py

# 1) 项目内 rpmbuild 树 + 产物目录
mkdir -p .rpmbuild/{BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS} dist

# 2) 写 spec 到 .rpmbuild/SPECS/${NAME}.spec
cat > .rpmbuild/SPECS/${NAME}.spec <<'SPEC'
Name:           kylin-ai-cryptojacking-detect
Version:        0.1.0
Release:        1%{?dist}
Summary:        Kylin AI Cryptojacking Detection Tool
License:        MIT
URL:            http://www.kylinos.cn
Source0:        %{name}-%{version}.tar.gz
BuildArch:      noarch

%undefine __brp_python_bytecompile
%global _python_bytecompile 0

BuildRequires:  python3
BuildRequires:  coreutils
BuildRequires:  findutils

Requires:       python3
Requires:       python3-psutil
Requires:       python3-pyyaml

%description
Kylin AI cryptojacking detection tool for Linux.

%prep
%autosetup -n %{name}-%{version}

%build
# pure Python

%install
APPDIR=%{buildroot}%{_libexecdir}/%{name}
install -d "$APPDIR"
cp -a src/* "$APPDIR/"

CFGDIR=%{buildroot}%{_sysconfdir}/%{name}
install -d "$CFGDIR"
test -d src/miner_sentinel_l1/src/config && \
  find src/miner_sentinel_l1/src/config -type f \( -name '*.yaml' -o -name '*.yml' \) -print0 \
  | xargs -0 -r install -m0644 -t "$CFGDIR"
test -d src/miner_sentinel_l2/src/config && \
  find src/miner_sentinel_l2/src/config -type f \( -name '*.yaml' -o -name '*.yml' \) -print0 \
  | xargs -0 -r install -m0644 -t "$CFGDIR"

install -Dpm0755 /dev/stdin %{buildroot}%{_bindir}/cryptojacking-detect <<'EOF'
#!/bin/sh
APPDIR="/usr/libexec/kylin-ai-cryptojacking-detect"
export PYTHONPATH="$APPDIR${PYTHONPATH:+:$PYTHONPATH}"
exec /usr/bin/python3 "$APPDIR/cryptojacking_detect.py" "$@"
EOF

( cd %{buildroot} && find . -type f -printf "/%P\n" | sort -u ) > installed-files.list
awk 'BEGIN{cfg="/etc/%{name}/"} { if (index($0,cfg)==1) print "%config(noreplace) "$0; else print $0 }' \
    installed-files.list > installed-files.list.new && mv installed-files.list.new installed-files.list

%files -f installed-files.list

%changelog
* Mon Oct 27 2025 You <you@example.com> 0.1.0-1
- In-repo build; outputs to ./dist and ./.rpmbuild
SPEC

# 3) 打 Source0：顶层必须是 Name-Version
TMP="$(mktemp -d)"
STAGE="$TMP/${NAME}-${VER}"
mkdir -p "$STAGE"
rsync -a --delete \
  --exclude ".git" --exclude ".rpmbuild" --exclude "dist" \
  ./ "$STAGE/"
tar -C "$TMP" -czf ".rpmbuild/SOURCES/${NAME}-${VER}.tar.gz" "${NAME}-${VER}"
rm -rf "$TMP"

# 4) 构建（使用项目内的 _topdir）
rpmbuild --define "_topdir $PWD/.rpmbuild" -ba ".rpmbuild/SPECS/${NAME}.spec"

# 5) 产物收集到 dist/
cp -av .rpmbuild/RPMS/*/*.rpm dist/ 2>/dev/null || true
cp -av .rpmbuild/SRPMS/*.src.rpm dist/ 2>/dev/null || true
cp -av .rpmbuild/SOURCES/${NAME}-${VER}.tar.gz dist/ 2>/dev/null || true

echo "✅ 完成。产物在 ./dist ："
ls -l dist/

-----------------------------------------------
sudo dnf -y remove kylin-ai-cryptojacking-detect || true
sudo dnf -y install ./dist/kylin-ai-cryptojacking-detect-*.noarch.rpm
cryptojacking-detect --help



error: .spec: line 51: %P: 预期为参数 —— 是 RPM 把 find -printf "/%P\n" 里的 %P 当成了宏，结果解析失败。

修复办法

把 spec 里生成文件清单那一行的 %P 转义成 %%P。

一键修补

在你的项目根执行：

sed -i 's%-printf "/%P\\n"%-printf "/%%P\\n"%' .rpmbuild/SPECS/kylin-ai-cryptojacking-detect.spec


如果你的包名不一样，把文件名替换一下就行。

为什么会这样？

在 spec 中，任何以 % 开头的内容都会被 RPM 当作“宏”处理；%P 不是定义好的宏，于是报“预期为参数”。

GNU find 的 -printf 里 %P 是“去掉前导 ./ 的路径”，所以我们需要写成 %%P 让 RPM 放过它，交给 find。

重新构建
rpmbuild --define "_topdir $PWD/.rpmbuild" -ba .rpmbuild/SPECS/kylin-ai-cryptojacking-detect.spec

如果仍然报错（可选备用写法）

不用 -printf，改用 sed 也可以生成清单（避免任何 %）——把 spec 中这两行：

( cd %{buildroot} && find . -type f -printf "/%P\n" | sort -u ) > installed-files.list
awk 'BEGIN{cfg="/etc/%{name}/"} { if (index($0,cfg)==1) print "%config(noreplace) "$0; else print $0 }' \
    installed-files.list > installed-files.list.new && mv installed-files.list.new installed-files.list


替换为：

( cd %{buildroot} && find . -type f | sed 's|^\./|/|' | sort -u ) > installed-files.list
awk 'BEGIN{cfg="/etc/%{name}/"} { if (index($0,cfg)==1) print "%config(noreplace) "$0; else print $0 }' \
    installed-files.list > installed-files.list.new && mv installed-files.list.new installed-files.list


这样就完全没有 %，也不会触发宏解析。
